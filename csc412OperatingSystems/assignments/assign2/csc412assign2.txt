Jason Laske
Professor Anand
3/5/2015

CSC 412: Operating Systems
Assignment 2 (30 points, due 3/6)


Note: Answer the questions precisely and give appropriate explanations and details. Figures, examples, justification/reasoning are important and will help explain your answer better. If computations are required, show all steps leading to the final answer.    

1.) (3 points) When (under what circumstances) is it appropriate for an operating system to “waste” or make in-efficient use of system resources? Explain and give examples to support your answer.


A GUI might waste CPU cycles, but it optimizes the user’s interaction with the system. A CPU can also waste CPU cycles during a Noop instruction. This might be used to ensure concurrency or parellelism between processes.  


2.) (3 points) In some computers, every byte of data read or written is directly handled by the CPU, through programmed I/O or interrupt driven I/O. There is no DMA. Is multiprogramming technically feasible with such an organization? Explain. 

Technically multiprogramming is possible with no DMA, yet there is no gain in performance. Multiprogramming refers to the process in which the CPU is able to allocate resources in a efficient manner to all requests made for such resources. With a DMA in a system there is some contention in handling these requests between the CPU and DMA. Without a DMA the CPU is left to handle 100% of the requests and thus is unable to have any additional time to handle other requests.


3.) 
a.) (4 points) Consider a personal computer in which keyboard interrupts arrive at the rate of 10 interrupts per sec. If the interrupt processing takes 50 micro seconds, what percentage of the CPU time is spent processing interrupts?
 
50/10^(-6) * 10 = .05% 


b.) (3 points) Consider the situation in a.) above, what is the maximum number of bytes that can be transferred to the CPU for processing per second?

(10^(-6) * .05)/8 = 118750 bytes 


4.) Write a C program that is invoked as testfork count and has the following specifications:
a.)	Takes a command line argument count, and forks off a (one) child process.
b.)	(8 points) The parent and child should then print on to the screen the following count times with their respective process ids: 
“I am the parent process and my process id is…”
“I am the child process and my process id is…”
c.)	Run the program for several values of the command line argument count, varying it from small values like 5-10 to large values like 500-1000.  Produce a script output showing the program listing and the execution for just one case with count = 30.  
d.)	(6 points) Next use the wait function to make the parent wait for the child to finish (save this as another program). Run the program for several values of the command line argument count, varying it from small values like 5-10 to large values like 500-1000.  Produce a script output showing the program listing and the execution for just one case with count = 30.
e.)	(3 points) Describe and explain precisely the differences you observe in the outputs generated by the two versions of the above program, for both small and large counts.

For small counts both programs run almost the same. For larger counts though the programs run the same with the exception that the parent process does not wait for the child process to finish before executing in the program that doesn't use wait(). This is non deterministic behaviour as both processes run concurrently after the call to fork().


Make sure all your code has appropriate comments and tests for errors.

